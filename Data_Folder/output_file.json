[
    {
        "id": null,
        "metadata": {
            "source": "Report.pdf",
            "time": "07/09/2024, 11:00:23"
        },
        "page_content": "Workplate AI REPORT Assignment Report Anshu Kumar Singh 9896843511 anshukumar9728@gmail.com Overview This Document tell all about the technical aspects of developing the workplate ai assignment also in that document i have mentioned how the project will initiate and also my include the approach used to develop this technology and some aspect of improving the document Tools and Technology ● Python ● Streamlit ● Ydata profiling Project Directory Structure workplate_assignment/ ├ ─ ─ analysis_engine/ # Main analysis logic │ ├ ─ ─ __init__.py # Makes this a Python package │ ├ ─ ─ analysis_eng.py # Contains analysis engine logic ├ ─ ─ data_processing/ # Data ingestion and preprocessing │ ├ ─ ─ __init__.py # Makes this a Python package │ ├ ─ ─ data_ingestion.py # Handles file validation and data cleaning ├ ─ ─ frontend_ui/ # Frontend application for user interaction │ ├ ─ ─ app.py # Streamlit app for user interface ├ ─ ─ README.md # Project documentation ├ ─ ─ requirements.txt # Required libraries and dependencies 1├ ─ ─ run.py # Script to run the entire system Data Ingestion Module: In that python module which is responsible for reading the all the excel csv and json file and perform the some cleaning steps of that data basically this module is used to clean the data and the load the dataset Analysis Engine: In that python module I have implement all the logic to Analysis the Data and Generate the result I have used the another tool for generating the report is ydata profiling to generate the report Frontend_ui: In that Module i have used the streamlit module to provide the user interface you can simply upload the file and this will generate the report automatically Challenges: 1. During the implementation of machine learning model i have faced the different type of dataset may have different type of column so it is some difficult to develop such a module which is able to handle all the different type of the data 2. When I am applying the LLM models to handle the above challenge their is another problem occur which is size constrained issue llm required large storage to store the model 2",
        "type": "Document"
    },
    {
        "id": null,
        "metadata": {
            "source": "anshu cv 6.3r.pdf",
            "time": "07/09/2024, 11:00:23"
        },
        "page_content": "Anshu Kumar Singh Data Science EnthusiasticDelhi NCR • 9896843511• anshukumar9728@gmail.com • linkedin.com/in/anshu-kumar-singh-3a6807179 • OBJECTIVE To secure a position in a dynamic organization where I can leverage my skills and passion for innovation as a recent computer science graduate. I am dedicated to contributing to the growth and success of the organization while continually expanding my own knowledge and expertise. PROFESSIONAL EXPERIENCE Imarc Services Pvt. Ltd – Noida, UP Automation Engineer, February 2024 – June 2024 ●Working With API To Efficient Data Connectivity ●Created technical documentation including the system specification, user manual and troubleshooting ●Supported the implementation of automation projects by assisting with equipment setup, programming, and testing activities. Relinns Technology– Mohali, Chandigarh NLP Engineer, August 2023 – September 2023 ●Working With Transformer Model to Make Large Language Model based Application to serve the Industry ●Working With Vector Database to store the Embedding and Trained Machine Learning Model ●Developed a Chatbot Application which worked under the LLM Application with Vector Database along the Transformer Model ●Worked With Some Other Technology such as Langchain, Web Scraping Tool bs4, Selenium PROJECT WORK ……………………………………………………………………………………….. Web_link_Document_ChatBot-WIth-LLama2 Machine Learning, Deep Learning, Transformers, Langchain ●Advanced Chatbot: Custom dataset and LLama2 model for sophisticated natural language processing. ●Efficient Data Handling: Utilizes Pinecone for storing chatbot embeddings, enabling swift and efficient data retrieval. ●User-Centric Approach: Focused on delivering personalized responses, the chatbot leverages its AI capabilities to provide intelligent and context-aware interactions. ●Redefining Conversational AI: Integration of custom data, LLama2, Pinecone, and transformers sets new standards for responsiveness and engagement. ●Innovation in Conversational Technology: The project showcases cutting-edge technologies to redefine the landscape of conversational AI. EDUCATION ADDITIONAL SKILLS BACHELOR IN TECHNOLOGY (Computer Science) Maharishi Dayanand University, Rohtak Year of Completion:2019-2023 Overall Percentage: 72% During my B. Tech program, I successfully completed my coursework and achieved an overall percentage of 72%. Throughout this educational journey, I gained extensive knowledge and developed valuable skills in my field of study. SENIOR SECONDARY EXAMINATION Govt. Senior Secondary School, Bahadurgarh Year of Completion:2019 Overall Percentage:68.4% During my Senior Secondary Education in the Science Stream. My core subjects are Physics, Chemistry and Mathematics. In that Exam I got overall 68%marks SECONDARY EXAMINATION Saraswati Bal Mandir High School, Bahadurgarh Year of Completion:2017 Overall Percentage:88.4% In my secondary examinations, I achieved an impressive Percentage 88.4 in 2017, showcasing my commitment to academic excellence. Proficient in diverse subjects, I received special recognition for outstanding performance in mathematics.●Python: Proficient in Python programming with experience in developing applications, implementing algorithms, and performing data analysis and manipulation. ●Natural Language Processing (NLP): Strong understanding of NLP concepts and techniques, including text preprocessing, tokenization, named entity recognition, sentiment analysis, and topic modeling. Familiarity with popular NLP libraries such as NLTK and SpaCy. ●Machine Learning: Extensive knowledge of machine learning algorithms and techniques, including supervised and unsupervised learning, regression, classification, clustering, and model evaluation. Practical experience in implementing machine learning models using Python libraries like scikit- learn and TensorFlow. ●Web Scraping: Proficient in web scraping techniques using Python and libraries like BeautifulSoup and Selenium. Experience in extracting data from websites, handling dynamic content ●Langchain Skills: Langchain excels in Natural Language Processing (NLP) andchatbotdevelopment,adeptly processing diverse language inputs. Its strength lies in seamlessly integrating custom datasets for nuanced ●Transformer Library Skills: Proficient in deep learning, the transformer library expertise ensures optimal contextual understanding. This skill set extends to implementing versatile sequence-to-sequence models for varied Natural Language Processing (NLP) tasks, with a commitment to stayingcurrentwiththelatestadvancements in transformer-based models REFERENCE …………………………. ●GITHUB ●Web_link_Document_ChatBot-WIth-LLama2 ●LINKIDIN ●LOAN REPAYENT STATUS ●SMS Spam Detection LANGUAGES………………………………………. Hindi Eng",
        "type": "Document"
    },
    {
        "id": null,
        "metadata": {
            "source": "https://fastapi.tiangolo.com/tutorial/query-params-str-validations/",
            "time": "07/09/2024, 11:01:10"
        },
        "page_content": "Query Parameters and String Validations - FastAPI Skip to content Follow @fastapi on Twitter to stay updated Subscribe to the FastAPI and friends newsletter 🎉 You can now sponsor FastAPI 🍰 sponsor sponsor sponsor sponsor sponsor sponsor sponsor sponsor sponsor sponsor sponsor FastAPI Query Parameters and String Validations en - English az - azərbaycan dili bn - বাংলা de - Deutsch es - español fa - فارسی fr - français he - עברית hu - magyar id - Bahasa Indonesia it - italiano ja - 日本語 ko - 한국어 nl - Nederlands pl - Polski pt - português ru - русский язык tr - Türkçe uk - українська мова ur - اردو vi - Tiếng Việt yo - Yorùbá zh - 简体中文 zh-hant - 繁體中文 😉 Initializing search fastapi/fastapi FastAPI Features Learn Reference FastAPI People Resources About Release Notes FastAPI fastapi/fastapi FastAPI Features Learn Learn Python Types Intro Concurrency and async / await Environment Variables Virtual Environments Tutorial - User Guide Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Query Parameters and String Validations Table of contents Additional validation Import Query and Annotated Use Annotated in the type for the q parameter Add Query to Annotated in the q parameter Alternative (old): Query as the default value Query as the default value or in Annotated Advantages of Annotated Add more validations Add regular expressions Pydantic v1 regex instead of pattern Default values Required parameters Required with Ellipsis (...) Required, can be None Query parameter list / multiple values Query parameter list / multiple values with defaults Using just list Declare more metadata Alias parameters Deprecating parameters Exclude parameters from OpenAPI Recap Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Form Models Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Dependencies Classes as Dependencies Sub-dependencies Dependencies in path operation decorators Global Dependencies Dependencies with yield Security Security Security - First Steps Get Current User Simple OAuth2 with Password and Bearer OAuth2 with Password (and hashing), Bearer with JWT tokens Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Advanced Security OAuth2 scopes HTTP Basic Auth Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients FastAPI CLI Deployment Deployment About FastAPI versions About HTTPS Run a Server Manually Deployments Concepts Deploy FastAPI on Cloud Providers Server Workers - Uvicorn with Workers FastAPI in Containers - Docker How To - Recipes How To - Recipes General - How To - Recipes GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI SQL (Relational) Databases with Peewee (deprecated) Async SQL (Relational) Databases with Encode/Databases (deprecated) NoSQL (Distributed / Big Data) Databases with Couchbase (deprecated) Reference Reference FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI OpenAPI OpenAPI docs OpenAPI models Security Tools Encoders - jsonable_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient FastAPI People Resources Resources Help FastAPI - Get Help Development - Contributing Full Stack FastAPI Template External Links and Articles FastAPI and friends newsletter Repository Management Tasks About About Alternatives, Inspiration and Comparisons History, Design and Future Benchmarks Repository Management Release Notes Table of contents Additional validation Import Query and Annotated Use Annotated in the type for the q parameter Add Query to Annotated in the q parameter Alternative (old): Query as the default value Query as the default value or in Annotated Advantages of Annotated Add more validations Add regular expressions Pydantic v1 regex instead of pattern Default values Required parameters Required with Ellipsis (...) Required, can be None Query parameter list / multiple values Query parameter list / multiple values with defaults Using just list Declare more metadata Alias parameters Deprecating parameters Exclude parameters from OpenAPI Recap FastAPI Learn Tutorial - User Guide Query Parameters and String Validations¶ FastAPI allows you to declare additional information and validation for your parameters. Let's take this application as example: Python 3.10+Python 3.8+ from fastapi import FastAPI app = FastAPI() @app.get(\"/items/\") async def read_items(q: str | None = None): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Union from fastapi import FastAPI app = FastAPI() @app.get(\"/items/\") async def read_items(q: Union[str, None] = None): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results The query parameter q is of type Union[str, None] (or str | None in Python 3.10), that means that it's of type str but could also be None, and indeed, the default value is None, so FastAPI will know it's not required. Note FastAPI will know that the value of q is not required because of the default value = None. The Union in Union[str, None] will allow your editor to give you better support and detect errors. Additional validation¶ We are going to enforce that even though q is optional, whenever it is provided, its length doesn't exceed 50 characters. Import Query and Annotated¶ To achieve that, first import: Query from fastapi Annotated from typing (or from typing_extensions in Python below 3.9) Python 3.10+Python 3.8+ In Python 3.9 or above, Annotated is part of the standard library, so you can import it from typing. from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[str | None, Query(max_length=50)] = None): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results In versions of Python below Python 3.9 you import Annotated from typing_extensions. It will already be installed with FastAPI. from typing import Union from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[Union[str, None], Query(max_length=50)] = None): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Info FastAPI added support for Annotated (and started recommending it) in version 0.95.0. If you have an older version, you would get errors when trying to use Annotated. Make sure you Upgrade the FastAPI version to at least 0.95.1 before using Annotated. Use Annotated in the type for the q parameter¶ Remember I told you before that Annotated can be used to add metadata to your parameters in the Python Types Intro? Now it's the time to use it with FastAPI. 🚀 We had this type annotation: Python 3.10+Python 3.8+ q: str | None = None q: Union[str, None] = None What we will do is wrap that with Annotated, so it becomes: Python 3.10+Python 3.8+ q: Annotated[str | None] = None q: Annotated[Union[str, None]] = None Both of those versions mean the same thing, q is a parameter that can be a str or None, and by default, it is None. Now let's jump to the fun stuff. 🎉 Add Query to Annotated in the q parameter¶ Now that we have this Annotated where we can put more information (in this case some additional validation), add Query inside of Annotated, and set the parameter max_length to 50: Python 3.10+Python 3.8+ from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[str | None, Query(max_length=50)] = None): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Union from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[Union[str, None], Query(max_length=50)] = None): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Notice that the default value is still None, so the parameter is still optional. But now, having Query(max_length=50) inside of Annotated, we are telling FastAPI that we want it to have additional validation for this value, we want it to have maximum 50 characters. 😎 Tip Here we are using Query() because this is a query parameter. Later we will see others like Path(), Body(), Header(), and Cookie(), that also accept the same arguments as Query(). FastAPI will now: Validate the data making sure that the max length is 50 characters Show a clear error for the client when the data is not valid Document the parameter in the OpenAPI schema path operation (so it will show up in the automatic docs UI) Alternative (old): Query as the default value¶ Previous versions of FastAPI (before 0.95.0) required you to use Query as the default value of your parameter, instead of putting it in Annotated, there's a high chance that you will see code using it around, so I'll explain it to you. Tip For new code and whenever possible, use Annotated as explained above. There are multiple advantages (explained below) and no disadvantages. 🍰 This is how you would use Query() as the default value of your function parameter, setting the parameter max_length to 50: Python 3.10+Python 3.8+ from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: str | None = Query(default=None, max_length=50)): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Union[str, None] = Query(default=None, max_length=50)): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results As in this case (without using Annotated) we have to replace the default value None in the function with Query(), we now need to set the default value with the parameter Query(default=None), it serves the same purpose of defining that default value (at least for FastAPI). So: q: Union[str, None] = Query(default=None) ...makes the parameter optional, with a default value of None, the same as: q: Union[str, None] = None And in Python 3.10 and above: q: str | None = Query(default=None) ...makes the parameter optional, with a default value of None, the same as: q: str | None = None But the Query versions declare it explicitly as being a query parameter. Info Keep in mind that the most important part to make a parameter optional is the part: = None or the: = Query(default=None) as it will use that None as the default value, and that way make the parameter not required. The Union[str, None] part allows your editor to provide better support, but it is not what tells FastAPI that this parameter is not required. Then, we can pass more parameters to Query. In this case, the max_length parameter that applies to strings: q: Union[str, None] = Query(default=None, max_length=50) This will validate the data, show a clear error when the data is not valid, and document the parameter in the OpenAPI schema path operation. Query as the default value or in Annotated¶ Keep in mind that when using Query inside of Annotated you cannot use the default parameter for Query. Instead use the actual default value of the function parameter. Otherwise, it would be inconsistent. For example, this is not allowed: q: Annotated[str, Query(default=\"rick\")] = \"morty\" ...because it's not clear if the default value should be \"rick\" or \"morty\". So, you would use (preferably): q: Annotated[str, Query()] = \"rick\" ...or in older code bases you will find: q: str = Query(default=\"rick\") Advantages of Annotated¶ Using Annotated is recommended instead of the default value in function parameters, it is better for multiple reasons. 🤓 The default value of the function parameter is the actual default value, that's more intuitive with Python in general. 😌 You could call that same function in other places without FastAPI, and it would work as expected. If there's a required parameter (without a default value), your editor will let you know with an error, Python will also complain if you run it without passing the required parameter. When you don't use Annotated and instead use the (old) default value style, if you call that function without FastAPI in other places, you have to remember to pass the arguments to the function for it to work correctly, otherwise the values will be different from what you expect (e.g. QueryInfo or something similar instead of str). And your editor won't complain, and Python won't complain running that function, only when the operations inside error out. Because Annotated can have more than one metadata annotation, you could now even use the same function with other tools, like Typer. 🚀 Add more validations¶ You can also add a parameter min_length: Python 3.10+Python 3.9+Python 3.8+Python 3.10+ non-AnnotatedPython 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[str | None, Query(min_length=3, max_length=50)] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Annotated, Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[Union[str, None], Query(min_length=3, max_length=50)] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Union from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[Union[str, None], Query(min_length=3, max_length=50)] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: str | None = Query(default=None, min_length=3, max_length=50)): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from typing import Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Union[str, None] = Query(default=None, min_length=3, max_length=50), ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Add regular expressions¶ You can define a regular expression pattern that the parameter should match: Python 3.10+Python 3.9+Python 3.8+Python 3.10+ non-AnnotatedPython 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[ str | None, Query(min_length=3, max_length=50, pattern=\"^fixedquery$\") ] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Annotated, Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[ Union[str, None], Query(min_length=3, max_length=50, pattern=\"^fixedquery$\") ] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Union from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[ Union[str, None], Query(min_length=3, max_length=50, pattern=\"^fixedquery$\") ] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: str | None = Query( default=None, min_length=3, max_length=50, pattern=\"^fixedquery$\" ), ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from typing import Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Union[str, None] = Query( default=None, min_length=3, max_length=50, pattern=\"^fixedquery$\" ), ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results This specific regular expression pattern checks that the received parameter value: ^: starts with the following characters, doesn't have characters before. fixedquery: has the exact value fixedquery. $: ends there, doesn't have any more characters after fixedquery. If you feel lost with all these \"regular expression\" ideas, don't worry. They are a hard topic for many people. You can still do a lot of stuff without needing regular expressions yet. But whenever you need them and go and learn them, know that you can already use them directly in FastAPI. Pydantic v1 regex instead of pattern¶ Before Pydantic version 2 and before FastAPI 0.100.0, the parameter was called regex instead of pattern, but it's now deprecated. You could still see some code using it: Python 3.10+ Pydantic v1 from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[ str | None, Query(min_length=3, max_length=50, regex=\"^fixedquery$\") ] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results But know that this is deprecated and it should be updated to use the new parameter pattern. 🤓 Default values¶ You can, of course, use default values other than None. Let's say that you want to declare the q query parameter to have a min_length of 3, and to have a default value of \"fixedquery\": Python 3.9+Python 3.8+Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[str, Query(min_length=3)] = \"fixedquery\"): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[str, Query(min_length=3)] = \"fixedquery\"): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: str = Query(default=\"fixedquery\", min_length=3)): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Note Having a default value of any type, including None, makes the parameter optional (not required). Required parameters¶ When we don't need to declare more validations or metadata, we can make the q query parameter required just by not declaring a default value, like: q: str instead of: q: Union[str, None] = None But we are now declaring it with Query, for example like: Annotatednon-Annotated q: Annotated[Union[str, None], Query(min_length=3)] = None q: Union[str, None] = Query(default=None, min_length=3) So, when you need to declare a value as required while using Query, you can simply not declare a default value: Python 3.9+Python 3.8+Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[str, Query(min_length=3)]): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[str, Query(min_length=3)]): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: str = Query(min_length=3)): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Notice that, even though in this case the Query() is used as the function parameter default value, we don't pass the default=None to Query(). Still, probably better to use the Annotated version. 😉 Required with Ellipsis (...)¶ There's an alternative way to explicitly declare that a value is required. You can set the default to the literal value ...: Python 3.9+Python 3.8+Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[str, Query(min_length=3)] = ...): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[str, Query(min_length=3)] = ...): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: str = Query(default=..., min_length=3)): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Info If you hadn't seen that ... before: it is a special single value, it is part of Python and is called \"Ellipsis\". It is used by Pydantic and FastAPI to explicitly declare that a value is required. This will let FastAPI know that this parameter is required. Required, can be None¶ You can declare that a parameter can accept None, but that it's still required. This would force clients to send a value, even if the value is None. To do that, you can declare that None is a valid type but still use ... as the default: Python 3.10+Python 3.9+Python 3.8+Python 3.10+ non-AnnotatedPython 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[str | None, Query(min_length=3)] = ...): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Annotated, Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[Union[str, None], Query(min_length=3)] = ...): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Union from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[Union[str, None], Query(min_length=3)] = ...): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: str | None = Query(default=..., min_length=3)): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from typing import Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Union[str, None] = Query(default=..., min_length=3)): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Pydantic, which is what powers all the data validation and serialization in FastAPI, has a special behavior when you use Optional or Union[Something, None] without a default value, you can read more about it in the Pydantic docs about Required fields. Tip Remember that in most of the cases, when something is required, you can simply omit the default, so you normally don't have to use .... Query parameter list / multiple values¶ When you define a query parameter explicitly with Query you can also declare it to receive a list of values, or said in another way, to receive multiple values. For example, to declare a query parameter q that can appear multiple times in the URL, you can write: Python 3.10+Python 3.9+Python 3.8+Python 3.10+ non-AnnotatedPython 3.9+ non-AnnotatedPython 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[list[str] | None, Query()] = None): query_items = {\"q\": q} return query_items from typing import Annotated, Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[Union[list[str], None], Query()] = None): query_items = {\"q\": q} return query_items from typing import List, Union from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[Union[List[str], None], Query()] = None): query_items = {\"q\": q} return query_items Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: list[str] | None = Query(default=None)): query_items = {\"q\": q} return query_items Tip Prefer to use the Annotated version if possible. from typing import Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Union[list[str], None] = Query(default=None)): query_items = {\"q\": q} return query_items Tip Prefer to use the Annotated version if possible. from typing import List, Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Union[List[str], None] = Query(default=None)): query_items = {\"q\": q} return query_items Then, with a URL like: http://localhost:8000/items/?q=foo&q=bar you would receive the multiple q query parameters' values (foo and bar) in a Python list inside your path operation function, in the function parameter q. So, the response to that URL would be: { \"q\": [ \"foo\", \"bar\" ] } Tip To declare a query parameter with a type of list, like in the example above, you need to explicitly use Query, otherwise it would be interpreted as a request body. The interactive API docs will update accordingly, to allow multiple values: Query parameter list / multiple values with defaults¶ And you can also define a default list of values if none are provided: Python 3.9+Python 3.8+Python 3.9+ non-AnnotatedPython 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[list[str], Query()] = [\"foo\", \"bar\"]): query_items = {\"q\": q} return query_items from typing import List from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[List[str], Query()] = [\"foo\", \"bar\"]): query_items = {\"q\": q} return query_items Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: list[str] = Query(default=[\"foo\", \"bar\"])): query_items = {\"q\": q} return query_items Tip Prefer to use the Annotated version if possible. from typing import List from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: List[str] = Query(default=[\"foo\", \"bar\"])): query_items = {\"q\": q} return query_items If you go to: http://localhost:8000/items/ the default of q will be: [\"foo\", \"bar\"] and your response will be: { \"q\": [ \"foo\", \"bar\" ] } Using just list¶ You can also use list directly instead of List[str] (or list[str] in Python 3.9+): Python 3.9+Python 3.8+Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[list, Query()] = []): query_items = {\"q\": q} return query_items from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[list, Query()] = []): query_items = {\"q\": q} return query_items Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: list = Query(default=[])): query_items = {\"q\": q} return query_items Note Keep in mind that in this case, FastAPI won't check the contents of the list. For example, List[int] would check (and document) that the contents of the list are integers. But list alone wouldn't. Declare more metadata¶ You can add more information about the parameter. That information will be included in the generated OpenAPI and used by the documentation user interfaces and external tools. Note Keep in mind that different tools might have different levels of OpenAPI support. Some of them might not show all the extra information declared yet, although in most of the cases, the missing feature is already planned for development. You can add a title: Python 3.10+Python 3.9+Python 3.8+Python 3.10+ non-AnnotatedPython 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[str | None, Query(title=\"Query string\", min_length=3)] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Annotated, Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[Union[str, None], Query(title=\"Query string\", min_length=3)] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Union from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[Union[str, None], Query(title=\"Query string\", min_length=3)] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: str | None = Query(default=None, title=\"Query string\", min_length=3), ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from typing import Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Union[str, None] = Query(default=None, title=\"Query string\", min_length=3), ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results And a description: Python 3.10+Python 3.9+Python 3.8+Python 3.10+ non-AnnotatedPython 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[ str | None, Query( title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, ), ] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Annotated, Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[ Union[str, None], Query( title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, ), ] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Union from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[ Union[str, None], Query( title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, ), ] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: str | None = Query( default=None, title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, ), ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from typing import Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Union[str, None] = Query( default=None, title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, ), ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Alias parameters¶ Imagine that you want the parameter to be item-query. Like in: http://127.0.0.1:8000/items/?item-query=foobaritems But item-query is not a valid Python variable name. The closest would be item_query. But you still need it to be exactly item-query... Then you can declare an alias, and that alias is what will be used to find the parameter value: Python 3.10+Python 3.9+Python 3.8+Python 3.10+ non-AnnotatedPython 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[str | None, Query(alias=\"item-query\")] = None): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Annotated, Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[Union[str, None], Query(alias=\"item-query\")] = None): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Union from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items(q: Annotated[Union[str, None], Query(alias=\"item-query\")] = None): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: str | None = Query(default=None, alias=\"item-query\")): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from typing import Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items(q: Union[str, None] = Query(default=None, alias=\"item-query\")): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Deprecating parameters¶ Now let's say you don't like this parameter anymore. You have to leave it there a while because there are clients using it, but you want the docs to clearly show it as deprecated. Then pass the parameter deprecated=True to Query: Python 3.10+Python 3.9+Python 3.8+Python 3.10+ non-AnnotatedPython 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[ str | None, Query( alias=\"item-query\", title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, max_length=50, pattern=\"^fixedquery$\", deprecated=True, ), ] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Annotated, Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[ Union[str, None], Query( alias=\"item-query\", title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, max_length=50, pattern=\"^fixedquery$\", deprecated=True, ), ] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results from typing import Union from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items( q: Annotated[ Union[str, None], Query( alias=\"item-query\", title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, max_length=50, pattern=\"^fixedquery$\", deprecated=True, ), ] = None, ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: str | None = Query( default=None, alias=\"item-query\", title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, max_length=50, pattern=\"^fixedquery$\", deprecated=True, ), ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results Tip Prefer to use the Annotated version if possible. from typing import Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( q: Union[str, None] = Query( default=None, alias=\"item-query\", title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, max_length=50, pattern=\"^fixedquery$\", deprecated=True, ), ): results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}]} if q: results.update({\"q\": q}) return results The docs will show it like this: Exclude parameters from OpenAPI¶ To exclude a query parameter from the generated OpenAPI schema (and thus, from the automatic documentation systems), set the parameter include_in_schema of Query to False: Python 3.10+Python 3.9+Python 3.8+Python 3.10+ non-AnnotatedPython 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( hidden_query: Annotated[str | None, Query(include_in_schema=False)] = None, ): if hidden_query: return {\"hidden_query\": hidden_query} else: return {\"hidden_query\": \"Not found\"} from typing import Annotated, Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( hidden_query: Annotated[Union[str, None], Query(include_in_schema=False)] = None, ): if hidden_query: return {\"hidden_query\": hidden_query} else: return {\"hidden_query\": \"Not found\"} from typing import Union from fastapi import FastAPI, Query from typing_extensions import Annotated app = FastAPI() @app.get(\"/items/\") async def read_items( hidden_query: Annotated[Union[str, None], Query(include_in_schema=False)] = None, ): if hidden_query: return {\"hidden_query\": hidden_query} else: return {\"hidden_query\": \"Not found\"} Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( hidden_query: str | None = Query(default=None, include_in_schema=False), ): if hidden_query: return {\"hidden_query\": hidden_query} else: return {\"hidden_query\": \"Not found\"} Tip Prefer to use the Annotated version if possible. from typing import Union from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read_items( hidden_query: Union[str, None] = Query(default=None, include_in_schema=False), ): if hidden_query: return {\"hidden_query\": hidden_query} else: return {\"hidden_query\": \"Not found\"} Recap¶ You can declare additional validations and metadata for your parameters. Generic validations and metadata: alias title description deprecated Validations specific for strings: min_length max_length pattern In these examples you saw how to declare validations for str values. See the next chapters to learn how to declare validations for other types, like numbers. Was this page helpful? Thanks for your feedback! Thanks for your feedback! Back to top Previous Request Body Next Path Parameters and Numeric Validations The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions Made with Material for MkDocs",
        "type": "Document"
    }
]